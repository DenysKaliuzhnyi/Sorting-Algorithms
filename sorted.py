def bubble(arr):
    """
    Начнем со сравнения первых двух элементов списка.
    Если первый элемент больше второго, мы меняем их местами.
    Если они уже в нужном порядке, мы оставляем их как есть.
    Затем мы переходим к следующей паре элементов, сравниваем
    их значения и меняем местами при необходимости.
    Этот процесс продолжается до последней пары элементов в списке.
    Достигнув конца списка, повторяем этот процесс для каждого элемента снова.
    Хотя это крайне неэффективно. Что если в массиве нужно сделать только одну замену?
    Почему мы все еще повторяем, даже если список уже отсортирован?
    Получается нам нужно пройти список n^2 раза. Очевидно, что для оптимизации
    алгоритма нам нужно остановить его, когда он закончит сортировку.
    Откуда нам знать, что мы закончили сортировку? Если бы элементы были отсортированы,
    то нам не пришлось бы их менять местами. Таким образом, всякий раз,
    когда мы меняем элементы, мы устанавливаем флаг в True, чтобы повторить процесс сортировки.
    Если перестановок не произошло, флаг останется False, и алгоритм остановится.
    Сложность пузырьковой сортировки в худшем случае (когда список отсортирован в обратном порядке) равна O(n^2).
    """
    nums = arr.copy()
    # We set swapped to True so the loop looks runs at least once
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # Swap the elements
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Set the flag to True so we'll loop again
                swapped = True
    return nums


def choice(arr):
    """
    Сортировка выбором
    1) найти наименьший элемент в массиве
    2) поменять местами его и первый элемент в массиве
    3) найти следующий наименьший элемент в массиве и поменять местами его и второй элемент массива
    4) продолжать это пока весь массив не будет отсортирован
    Сложность сортировки выбором в среднем составляет O(n^2).
    """
    nums = arr.copy()
    # значение i соответствует тому, сколько значений было отсортировано
    for i in range(len(nums)):
        # Мы предполагаем, что первый элемент несортированного сегмента является наименьшим
        indx_min = i
        # Этот цикл перебирает несортированные элементы
        for j in range(i+1, len(nums)):
            if nums[j] < nums[indx_min]:
                indx_min = j
        # Поменять местами значения самого низкого несортированного элемента с первым несортированным
        nums[i], nums[indx_min] = nums[indx_min], nums[i]
    return nums


def insert(arr):
    """
    Сортировка вставками
    Предполагается, что первый элемент списка отсортирован.
    Затем мы переходим к следующему элементу, назовем его х.
    Если x больше первого элемента, мы оставляем его как есть.
    Если x меньше, мы копируем значение первого элемента во вторую
    позицию и затем устанавливаем первый элемент в x.
    Когда мы переходим к другим элементам несортированного сегмента,
    мы непрерывно перемещаем более крупные элементы в отсортированном
    сегменте вверх по списку, пока не встретим элемент меньше x,
    или не достигнем конца отсортированного сегмента,
    а затем поместим x в его правильное положение.
    Сложность сортировки вставками в среднем равна O(n^2).
    """
    nums = arr.copy()
    # Начнем со второго элемента, так как мы предполагаем, что первый элемент отсортирован
    for i in range(1, len(nums)):
        item_to_insert = nums[i]
        # И сохранить ссылку на индекс предыдущего элемента
        j = i - 1
        # Переместить все элементы отсортированного сегмента вперед, если они больше, чем элемент для вставки
        while j >= 0 and nums[j] > item_to_insert:
            nums[j + 1] = nums[j]
            j -= 1
        # Вставляем элемент
        nums[j + 1] = item_to_insert
    return nums


def heap(arr):
    """
    Начинаем с преобразования списка в MaxHeap – бинарное сбалансированное дерево,
    где самым большим элементом является корневой узел, а также любой узел больше
    всех своих потомком. Второй шаг - меняем местами корневой и последний елементы и
    перестраиваем дерево без учета смещенной в конец вернины. Такую процедуру
    выполняем для каждой вершины (начиная с конца списка-дерева)
    В среднем сложность сортировки кучи составляет O(n*log(n)),
    """
    def heapify(arr, heap_size, root_index):
        # Предположим, что индекс самого большого элемента является корневым индексом
        largest = root_index
        left_child = (2 * root_index) + 1
        right_child = (2 * root_index) + 2
        # Если левый потомок корня является допустимым индексом, а элемент больше
        # чем текущий самый большой элемент, то обновляем самый большой элемент
        if left_child < heap_size and arr[left_child] > arr[largest]:
            largest = left_child
        # Делайте то же самое для right_child
        if right_child < heap_size and arr[right_child] > arr[largest]:
            largest = right_child
        # Если самый большой элемент больше не является корневым элементом, меняем их местами
        if largest != root_index:
            arr[root_index], arr[largest] = arr[largest], arr[root_index]
            # Heapify the new root element to ensure it's the largest
            heapify(arr, heap_size, largest)

    nums = arr.copy()
    n = len(nums)
    # Создаем Max Heap из списка
    for i in range(n-1, -1, -1):
        heapify(nums, n, i)
    # Перемещаем корень в конец
    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)
    return nums


def merge(arr):
    """
    Рекурсивно разделяем список пополам, пока не получим списки с одиночным размером.
    Затем объединяем каждую половину, которая была разделена, и при этом сортируя их.
    Сортировка осуществляется путем сравнения наименьших элементов каждой половины.
    Первый элемент каждого списка сравнивается с первым. Если первая половина начинается
    с меньшего значения, то мы добавляем ее в отсортированный список. Затем мы сравниваем
    второе наименьшее значение первой половины с первым наименьшим значением второй половины.
    Каждый раз, когда мы выбираем меньшее значение в начале половины, мы перемещаем индекс,
    элемент которого нужно сравнить на единицу.
    В среднем сложность сортировки слиянием составляет O(n*log(n)).
    """
    def _merge(left_list, right_list):
        sorted_list = []
        left_list_index = right_list_index = 0
        # Мы будет часто используем длины списков, поэтому удобно сразу создавать переменные для этого
        left_list_length, right_list_length = len(left_list), len(right_list)
        for _ in range(left_list_length + right_list_length):
            if left_list_index < left_list_length and right_list_index < right_list_length:
                # Мы проверяем, какое значение с начала каждого списка меньше
                # Если элемент в начале левого списка меньше, добавляем его в отсортированный список
                if left_list[left_list_index] <= right_list[right_list_index]:
                    sorted_list.append(left_list[left_list_index])
                    left_list_index += 1
                # Если элемент в начале правого списка меньше, добавляем его в отсортированный список
                else:
                    sorted_list.append(right_list[right_list_index])
                    right_list_index += 1
            # Если мы достигли конца левого списка, добавляем элементы из правого списка
            elif left_list_index == left_list_length:
                sorted_list.append(right_list[right_list_index])
                right_list_index += 1
            # Если мы достигли конца правого списка, добавляем элементы из левого списка
            elif right_list_index == right_list_length:
                sorted_list.append(left_list[left_list_index])
                left_list_index += 1
        return sorted_list

    # Если список представляет собой один элемент, возвращаем его
    if len(arr) <= 1:
        return arr
    # Используем деление с округленим по наименьшему целому для получения средней точки
    mid = len(arr) // 2
    # Сортируем и объединяем каждую половину
    left_list = merge(arr[:mid])
    right_list = merge(arr[mid:])
    # Объединить отсортированные списки в новый
    return _merge(left_list, right_list)


def quick(arr):
    """
    Быстрая сортировка начинается с разбиения списка – выбора одного значения списка,
    которое будет в его отсортированном месте. Это значение называется опорным.
    Все элементы, меньшие, чем этот элемент, перемещаются влево.
    Все более крупные элементы перемещены вправо.
    Зная, что опорный элемент находится на своем правильном месте,
    мы рекурсивно сортируем значения вокруг этого элемента,
    пока не будет отсортирован весь список.
    В среднем сложность быстрой сортировки составляет O(nlog (n)).
    Примечание. Алгоритм быстрой сортировки будет работать медленно,
    если опорный элемент будет наименьшим или наибольшим элементом списка.
    Быстрая сортировка обычно работает быстрее с более сбалансированными значениями.
    В отличие от сортировки кучи и сортировки слиянием, обе из которых имеют худшие
    времена O(n*log(n)), быстрая сортировка имеет худшее время O(n^2).
    """
    # Есть разные способы реализовать быструю сортировки
    # мы выбрали схему Tony Hoare
    def partition(nums, low, high):
        # Мы выбираем средний элемент, в качестве опорного. Некоторые реализации выбирают
        # первый элемент или последний элемент или вообще случайный элемент.
        pivot = nums[(low + high) // 2]
        i = low - 1
        j = high + 1
        while True:
            i += 1
            while nums[i] < pivot:
                i += 1
            j -= 1
            while nums[j] > pivot:
                j -= 1
            if i >= j:
                return j
            # Если элемент в i (слева от оси) больше, чем
            # элемент в J (справа от оси), то поменять их местами
            nums[i], nums[j] = nums[j], nums[i]
    # Создаем вспомогательную рекурсивную функцию

    def _quick(items, low, high):
        if low < high:
            # Это индекс после опорного элемента, по которому наши списки разделены
            split_index = partition(items, low, high)
            _quick(items, low, split_index)
            _quick(items, split_index + 1, high)

    nums = arr.copy()
    _quick(nums, 0, len(nums) - 1)
    return nums
